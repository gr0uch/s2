<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>s²</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDQuMjMzMzMzMyA0LjIzMzMzMzMiPjxnPjxwYXRoIGZpbGw9IiMzZmI2OGIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTAgMGg0LjIzM3Y0LjIzM2gtNC4yMzN6Ii8+PHBhdGggZD0iTTEuNDE2LjgzMXEtLjQwMy4zLS40MDMuNjQ2IDAgLjQ0NC4zMi40NDQuMTE0IDAgLjM2Mi0uMTk2dC40ODYtLjE5NnEuMjI3IDAgLjM2Ny4xMTkuMTQuMTE0LjE0LjMwNSAwIC4xODEtLjE4MS4zODItLjE4MS4xOTYtLjY0MS40NS0uNDYuMjQ4LS41ODQuMzMxLS4xMjQuMDg4LS4yMTIuMjEybC0uMDI2LS4wMzEuMDMxLS4wNjIuMDM2LS4wNzgtLjA4OC0uMTAzcS0uMDgzLS4wNzgtLjIyMi0uMDc4LS4yNTggMC0uNDA4LjI2OWwtLjAyNi4wMzEtLjAzMS0uMDMxcTAtLjA4My4yMzMtLjMyLjIzOC0uMjQzLjU2My0uMjQzLjI0MyAwIC40MjQuMTU1bC4wNDEuMDI2LjA3Mi0uMDQxcS4zNDYtLjE4MS40NDQtLjMzMS4wOTgtLjE1LjA5OC0uMzE1IDAtLjE4MS0uMTA5LS4yODQtLjEwMy0uMTA5LS4yNzQtLjEwOS0uMTI0IDAtLjM3Ny4xOTYtLjI0OC4xOTYtLjQ2LjE5Ni0uMTY1IDAtLjI4NC0uMTI5LS4xMTktLjEzNC0uMTE5LS4zMTUgMC0uMjU4LjIyNy0uNTE3LjIyNy0uMjU4LjgxNi0uNTY4LjI4OS0uMTU1LjQwMy0uMzI2bC4wMTYtLjAyMS4wMjEuMDQxLS4wOTMuMTI0LS4wODguMTI0cS4xNzEuMTQ1LjI3OS4xNDUuMTM0IDAgLjI4NC0uMTAzbC4wMjEuMDMxcTAgLjAyNi0uMjQzLjI0My0uMjM4LjIxMi0uMzcyLjIxMi0uMTI0IDAtLjQ0NC0uMjg0eiIgc3R5bGU9ImxpbmUtaGVpZ2h0OjEuMjU7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpQYXJjaG1lbnQ7cGFpbnQtb3JkZXI6bm9ybWFsIiBmb250LXNpemU9IjEwLjU4MyIgZm9udC1mYW1pbHk9IlBhcmNobWVudCIgc3Ryb2tlPSIjZmZmIiBzdHJva2Utd2lkdGg9Ii4xMzIiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIGZpbGw9Im5vbmUiLz48cGF0aCBkPSJNMS44ODMgMy45NTZsLjQzMi0uMzk3LjM0LS4zMjdxLjMwMi0uMjg2LjQtLjQ5NS4wOTgtLjIxLjA5OC0uNDQ4IDAtLjI2Ny0uMTExLS40MjItLjEwOC0uMTU2LS4zMTgtLjE1Ni0uMTUyIDAtLjI4Ni4wODMtLjEzLjA3OS0uMTMuMTcxIDAgLjE1Mi4xNjUuMTUyLjEyMSAwIC4xOTQuMDczLjA3Ni4wNy4wNzYuMTg0IDAgLjE0My0uMDk4LjIzOHQtLjI0MS4wOTVxLS4xNzggMC0uMjk1LS4xMDItLjExNy0uMTA1LS4xMTctLjI3MyAwLS4xOTcuMTMzLS4zNTYuMTMzLS4xNjIuMjk4LS4yMzUuMTY4LS4wNzMuMjk1LS4wOTJsLjI3Ni0uMDIycS4zODQgMCAuNjU0LjE3MXQuMjcuNDk1cTAgLjIwMy0uMTI3LjM2Mi0uMTI0LjE1OS0uMjc5LjI0MS0uMTU2LjA3OS0uNDc5LjIwNi0uMzIxLjEyNC0uMzU2LjE4MXYuMDEzbC4xODEtLjAxLjIyMi0uMDAzaC41MDJxLjE1NiAwIC4yMTktLjAzOGwuMDkyLS4xMDguMDUxLS4xMzcuMDM4LS4xMTFoLjA0MWwtLjIwMyAxLjA4NmgtMS45Mzd6IiBzdHlsZT0ibGluZS1oZWlnaHQ6MS4yNTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOkVsZXBoYW50IiBmb250LXNpemU9IjMuMTc1IiBmb250LWZhbWlseT0iRWxlcGhhbnQiLz48L2c+PC9zdmc+" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta property="og:title" content="s²">
    <meta property="og:description" content="s² is a function for reactive web UI." />
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://gr0uch.github.io/s2/s2.png">
    <meta property="og:image:type" content="image/png">
    <script type="module" src="./docs.mjs"></script>
    <style>
      :root {
        --w: 77rem;
        --h: 19px;
        --h2: 17px;
        --h3: 14px;
        --h4: 12px;
        --l: calc(1rem * var(--u) * 7);
        --u: calc(1 / 4);

        /*--f-h: Garamond, Big Caslon Medium, Palatino Linotype, Palatino, serif;*/
        --f-b: Space Grotesk, -apple-system, BlinkMacSystemFont, Microsoft Sans Serif, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        --f-m: Space Mono, SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;

        --c-bg: #fff;
        --c-fg: #000;
        --c-fg2: #666;
        --c-fg3: #bbb;
        --c-a: rgb(240, 240, 240);
        --c-a2: rgb(225, 225, 225);
        --c-j: #f1e05a;
        --c-l: #3fb68b;
        --c-l2: rgba(63, 182, 139, 0.08);
        --c-h: #e34c26;
        --c-e: #6e40c9;
        --c-e2: #5d33b0;
      }
      ::selection { background: var(--c-j); color: var(--c-fg); }
      * { margin: 0; padding: 0; border: 0; box-sizing: border-box; }
      html { font-size: var(--h); }
      body { line-height: var(--l); background: var(--c-a); color: var(--c-fg); font-family: var(--f-b); }
      h1, h2, h3, h4, h5, h6 { font-size: inherit; font-weight: inherit; }
      h2 { font-size: calc(1rem * var(--u) * 5); font-weight: 700; margin: calc(1rem * 12 * var(--u)) 0 var(--l); padding: calc(1rem * var(--u) * 2) 0; }
      h2 code { font-size: inherit; }
      h3 { font-size: 1rem; font-weight: 700; margin: 0 0 var(--l); }
      h6 { font-size: var(--h3); text-transform: uppercase; font-weight: 300; font-style: italic; letter-spacing: 0.1rem; color: var(--c-fg2); }
      ul, ol { padding-left: 2rem; }
      p, ul, ol, pre, blockquote { margin-bottom: var(--l); }
      blockquote { color: var(--c-fg2); border-left: calc(1rem * var(--u) * 1) var(--c-fg3) solid; padding-left: calc(1rem * var(--u) * 3); }
      a { color: inherit; text-decoration: inherit; }
      code, pre { font-family: var(--f-m); font-size: var(--h2); }
      textarea, pre { background: none; padding: calc(1rem * var(--u) * 2) calc(1rem * var(--u) * 3); font-family: var(--f-m); font-size: var(--h3); resize: vertical; font-variant-ligatures: none; }
      pre { box-shadow: 0 calc(1rem * var(--u) * 3) calc(1rem * var(--u) * 9) var(--c-a2); border-radius: calc(1rem * var(--u)); white-space: pre-wrap; counter-reset: line; }
      pre > code { display: block; counter-increment: line; position: relative; padding: 0 0 0 calc(1rem * var(--u) * 6) !important; font-size: inherit; }
      pre > code::before { content: counter(line); display: inline-block; position: absolute; top: 0; right: calc(100% - 1rem * var(--u) * 4); color: var(--c-fg3); }
      textarea:focus, input:focus { outline: 1px var(--c-l) solid; }

      /* layout */
      .container { position: relative; min-height: 100%; max-width: var(--w); display: flex; margin: auto; hyphens: auto; }
      body::before { display: block; content: " "; position: fixed; top: 0; right: 0; height: 100%; width: calc((100% - var(--w)) / 2 + 1px); background: var(--c-a2); }
      #main-nav { position: sticky; top: calc(1rem * var(--u) * -10); flex: 1; padding: 0 calc(1rem * var(--u) * 4) 0 calc(1rem * var(--u) * 1); align-self: flex-start; color: var(--c-fg2); }
      #main-nav h5 { font-size: var(--h3); font-weight: 700; }
      #main-nav code { font-size: var(--h4); }
      #main-nav h5 + h5 { margin-top: var(--l); }
      #main-nav ul { padding: 0; list-style-type: none; font-style: italic; font-size: var(--h3); font-weight: 300; }
      #main-nav li::before { content: "-"; margin-right: calc(1rem * var(--u) * 1); color: var(--c-fg3); }
      #main-nav .logo { position: sticky; top: 0; width: calc(1rem * var(--u) * 8); padding-top: calc(1rem * var(--u) * 2); background: var(--c-l); margin-bottom: calc(1rem * 20 * var(--u)); border-bottom: var(--c-l) calc(1rem * var(--u) * 1) solid; border-radius: 0 0 calc(1rem * var(--u)) calc(1rem * var(--u)); }
      #main-nav svg { display: block; height: calc(1rem * var(--u) * 8); width: calc(1rem * var(--u) * 8); }
      #content { flex: 5; }
      #content a, #main-nav h5 a { text-decoration: underline var(--c-l) 2px; }
      #content > section { display: grid; grid-template-columns: 5fr 2fr; grid-template-rows: min-content; border-bottom: 2px var(--c-a2) solid; }
      #content > section > div { padding: 0 calc(1rem * var(--u) * 16) 0 0; position: relative; }
      #content > section > div:nth-of-type(2n) { padding: 0 var(--l); }
      #content > section > div:nth-of-type(2n)::before { display: block; content: " "; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--c-a2); z-index: -1; }
      #content > section > div:last-of-type { padding-bottom: calc(1rem * var(--u) * 16); }
      #content > section > div:nth-last-of-type(2) > :last-child { margin-bottom: calc(1rem * var(--u) * 16) !important; }
      #content > section > div > :last-child:not(.live-example.code) { margin-bottom: 0; }
      #content > section > div > footer { padding: var(--l) 0 0; color: var(--c-fg3); text-align: center; }
      #content > section > div > footer > h4 { font-size: 2em; }
      #content > section code { background: var(--c-a2); border-radius: calc(1rem * var(--u)); padding: 0 calc(1rem * var(--u)); }
      #content > section pre code { background: inherit; border-radius: inherit; }
      .tagline { color: var(--c-fg3); font-size: var(--h3); padding-top: calc(1rem * var(--u) * 2); }
      .params { position: relative; z-index: 0; margin: calc(1rem * var(--u) * 20) calc((100% * -3 / 7) - 1rem * var(--u) * 0) calc(1rem * var(--u) * -22) 0; font-size: calc(1rem * var(--u) * 5); line-height: calc(1rem * var(--u) * 10); border-radius: calc(1rem * var(--u)); color: var(--c-l); padding: calc(1rem * var(--u) * 0) calc(1rem * var(--u) * 16) calc(1rem * var(--u) * 38) 0; }
      .params b { display: inline-block; width: calc(1rem * var(--u) * 24); }
      .params i { display: inline-block; margin-right: calc(1rem * var(--u) * 2); }
      .params code { background: none !important; text-decoration: underline; font-size: inherit; }

      /* examples */
      .live-example.code { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: min-content 1fr; box-shadow: 0 calc(1rem * var(--u) * 4) calc(1rem * var(--u) * 8) var(--c-a2); border-radius: calc(1rem * var(--u)); margin-bottom: calc(1rem * var(--u) * 10); }
      .live-example.code h6 { background: var(--c-bg); padding: calc(1rem * var(--u) * 1) calc(1rem * var(--u) * 3); border-bottom: 1px var(--c-a2) solid; border-right: 1px var(--c-a2) solid; }
      .live-example.code h6:first-of-type { border-radius: calc(1rem * var(--u)) 0 0 0; }
      .live-example.code h6:last-of-type { border-radius: 0 calc(1rem * var(--u)) 0 0; border-right: none; }
      .live-example.code textarea { height: 100%; border-right: 1px var(--c-a2) solid; }
      .live-example.code textarea:last-of-type { border-right: none; }
      aside { color: var(--c-fg2); font-size: var(--h3); }
      aside code { font-size: inherit; }
      aside h6 { padding: calc(1rem * var(--u) * 1) 0; margin-bottom: calc(1rem * var(--u) * 2); border-bottom: 1px var(--c-fg3) solid; }
      .live-example.output ul { list-style-type: circle; padding: 0 0 0 calc(1rem * var(--u) * 4); margin: 0; }
      .live-example.output li > div { float: right; color: var(--c-h); cursor: pointer; font-weight: 700; }
      aside:not(.output) { margin-top: calc(1rem * var(--u) * 16); }
      .live-example.output .chars { display: inline-flex; }
      .live-example.output .chars > * { pointer-events: none; }
      @keyframes char-in { 0% { transform: scale(5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
      @keyframes char-out { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(5); opacity: 0; } }
      .live-example.output .in { animation: char-in 0.5s; }
      .live-example.output .out { animation: char-out 0.5s; }
      .live-example.output .nums { display: inline-flex; }
      .live-example.output .nums > * { margin: 0 calc(1rem * var(--u) * 1); }
      .live-example.output .spreadsheet { display: grid; grid-template-columns: 1fr 1fr 1fr; column-gap: calc(1rem * var(--u) * 3); row-gap: calc(1rem * var(--u) * 1); }
      .live-example.output .todo > :nth-child(2) { display: none; }
      .live-example.output .todo[data-confirm] > :nth-child(2) { display: block; }
      .live-example.output .todo[data-confirm] > :nth-child(1) { display: none; }
      .live-example.output .example-list { max-height: calc(var(--l) * 8); overflow: auto; }
      .live-example.output .example-list > * { cursor: pointer; }
      .live-example.output .example-list [data-selected="false"] { display: none; }

      /* primary */
      .live-example.primary.code { position: relative; left: calc(1rem * var(--u) * 0); margin-right: calc(1rem * var(--u) * 0); }
      .live-example.primary.code h6 { background: var(--c-l2); }
      .live-example.primary.code textarea { background: var(--c-a); }
      .live-example.primary.output { background: var(--c-l2); backdrop-filter: blur(var(--h4)); margin: 0 calc(1rem * var(--u) * -4); padding: 0 calc(1rem * var(--u) * 4) calc(1rem * var(--u) * 4); border-radius: calc(1rem * var(--u)); }
      .live-example.primary.output input { background: var(--c-bg); }
      .live-example.primary.output input:focus { outline: none; }
      .live-example.primary h6 { color: var(--c-l); border-bottom-width: 2px; border-bottom-color: var(--c-l); font-weight: 700; font-style: inherit; padding-top: calc(1rem * var(--u) * 2); }

      /* forms */
      form { display: flex; margin: calc(1rem * var(--u) * 4) 0; }
      form > :first-child { border-radius: calc(1rem * var(--u)) 0 0 calc(1rem * var(--u)); }
      form > :last-child { border-radius: 0 calc(1rem * var(--u)) calc(1rem * var(--u)) 0; }
      input, button { font-family: inherit; font-size: inherit; background: inherit; color: inherit; }
      form button { background: var(--c-bg); }
      form input { width: 0; }
      input { background: var(--c-a); height: calc(1rem * var(--u) * 7); padding: 0 calc(1rem * var(--u) * 2); flex: 1; width: 100%; border-radius: calc(1rem * var(--u)); }
      button { cursor: pointer; padding: 0 calc(1rem * var(--u) * 3); color: var(--c-e); font-weight: 700; }

      /* rEspoNsiVe */
      @media (max-width: 1240px) {
        :root {
          --h: 17px;
          --h3: 12px;
        }
        .container { flex-direction: column; }
        .params { margin: calc(1rem * var(--u) * 8) 0; padding: calc(var(--l) * 1 / 2); }
        h2 { margin-top: calc(1rem * var(--u) * 6); }
        #main-nav { position: static; }
        #main-nav .logo { margin-bottom: 0; position: static; }
        #main-nav .logo ~ * { display: none; }
        .live-example.primary.code { position: inherit; left: 0; margin-right: 0; }
        #content { padding: 0 calc(1rem * var(--u) * 1); }
        #content > section { display: block; }
        #content > section > div { padding: 0; }
        #content > section > div:nth-child(2) { padding-top: 0; }
        #content > section > div:last-of-type { padding-bottom: 0; }
        #content > section > div:nth-of-type(2n + 1) > :last-child { margin-bottom: calc(1rem * var(--u) * 8); }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav id="main-nav">
        <div class="logo">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 4.2333333 4.2333333"><g><path fill="#3fb68b" fill-rule="evenodd" d="M0 0h4.233v4.233h-4.233z"/><path d="M1.416.831q-.403.3-.403.646 0 .444.32.444.114 0 .362-.196t.486-.196q.227 0 .367.119.14.114.14.305 0 .181-.181.382-.181.196-.641.45-.46.248-.584.331-.124.088-.212.212l-.026-.031.031-.062.036-.078-.088-.103q-.083-.078-.222-.078-.258 0-.408.269l-.026.031-.031-.031q0-.083.233-.32.238-.243.563-.243.243 0 .424.155l.041.026.072-.041q.346-.181.444-.331.098-.15.098-.315 0-.181-.109-.284-.103-.109-.274-.109-.124 0-.377.196-.248.196-.46.196-.165 0-.284-.129-.119-.134-.119-.315 0-.258.227-.517.227-.258.816-.568.289-.155.403-.326l.016-.021.021.041-.093.124-.088.124q.171.145.279.145.134 0 .284-.103l.021.031q0 .026-.243.243-.238.212-.372.212-.124 0-.444-.284z" stroke="#fff" stroke-width=".132" stroke-linecap="square" fill="none"/><path d="M1.883 3.956l.432-.397.34-.327q.302-.286.4-.495.098-.21.098-.448 0-.267-.111-.422-.108-.156-.318-.156-.152 0-.286.083-.13.079-.13.171 0 .152.165.152.121 0 .194.073.076.07.076.184 0 .143-.098.238t-.241.095q-.178 0-.295-.102-.117-.105-.117-.273 0-.197.133-.356.133-.162.298-.235.168-.073.295-.092l.276-.022q.384 0 .654.171t.27.495q0 .203-.127.362-.124.159-.279.241-.156.079-.479.206-.321.124-.356.181v.013l.181-.01.222-.003h.502q.156 0 .219-.038l.092-.108.051-.137.038-.111h.041l-.203 1.086h-1.937z" /></g></svg>
        </div>
        <h5><a href="https://github.com/gr0uch/s2">GitHub: gr0uch/s2</a></h5>
        <h5>Intro</h5>
        <ul>
          <li><a href="#rationale">Rationale</a></li>
          <li><a href="#import-the-module">Import the module</a></li>
          <li><a href="#reactive-templating">Reactive templating</a></li>
        </ul>
        <h5>Templating</h5>
        <ul>
          <li><a href="#html-templates">HTML templates</a></li>
          <li><a href="#mustache-templates">Mustache templates</a></li>
          <li><a href="#registering-templates">Registering templates</a></li>
        </ul>
        <h5>Advanced usage</h5>
        <ul>
          <li><a href="#mount-unmount-symbols"><code>mount</code>, <code>unmount</code> symbols</a></li>
          <li><a href="#move-symbol"><code>move</code> symbol</a></li>
          <li><a href="#root-target-symbol"><code>root</code>, <code>target</code> symbol</a></li>
          <li><a href="#computed-properties">Computed properties</a></li>
          <li><a href="#computed-composition">Computed composition</a></li>
        </ul>
        <h5>Addendum</h5>
        <ul>
          <li><a href="#performance-pitfalls">Performance pitfalls</a></li>
          <li><a href="#object-re-use">Object re-use</a></li>
          <li><a href="#computed-of-computed">Computed of computed</a></li>
          <li><a href="#server-side-rendering">Server-side rendering</a></li>
        </ul>
      </nav>
      <main id="content">
        <section>
          <div>
            <p class="tagline" id="top">A function for reactive web UI.</p>
            <p class="params">
              <em>s²</em> &mdash; Reactive templating function.<br><br>
              <em><b>Input</b> <i>&larr;</i></em> <code>Object</code>, <code>&lt;template&gt;</code><br>
              <em><b>Output</b> <i>&rarr;</i></em> <code>Proxy</code>, <code>DocumentFragment</code>
            </p>
            <hr>
          </div>
          <div></div>
          <div>
            <div class="live-example primary code" style="min-height: calc(1rem * var(--u) * 72)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  add, todos: [
    'Sleep', 'Wake up',
    'Brush teeth', 'Get dressed',
  ].map(todo => ({ todo, remove })),
};
function add(event) {
  event.preventDefault();
  this[root].todos.unshift({
    todo: this.todo, remove });
  delete this.todo;
}
function remove() {
  const i = this[root].todos
    .findIndex(_ => _ === this);
  this[root].todos.splice(i, 1);
}</textarea><textarea spellcheck="false"><form onsubmit="{{add}}">
  <input required
    value="{{todo}}"
    placeholder="Todo...">
  <button>Add</button>
</form>
<ul>
  {{#todos}}
    <li>
      <div onclick="{{remove}}">
        &#x2715;</div>
      <span>{{todo}}</span>
    </li>
  {{/todos}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example primary output" style="min-height: calc(1rem * var(--u) * 72)">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
        </section>

        <section>
          <div>
            <h2 id="rationale">Rationale</h2>
            <p>A single function is capable of expressing the most complex web applications. <em>s²</em> has a few design goals:</p>
            <ul>
              <li>The only required API is its main function. Advanced features such as computed properties are implemented as addons.</li>
              <li>Templates are logic-less. This differs from prior art such as JSX where embedded JavaScript is allowed. Due to this constraint, logic-less templating maps well to <em>s²</em>, and there is an addon for <a href="#mustache-templates">Mustache templates</a> that is aware of HTML context.</li>
            </ul>
            <p>Its design is influenced by this quote:</p>
            <blockquote>Even the simplest procedural logic is hard for humans to verify, but quite complex data structures are fairly easy to model and reason about... Data is more tractable than program logic. It follows that where you see a choice between complexity in data structures and complexity in code, choose the former. More: in evolving a design, you should actively seek ways to shift complexity from code to data.</blockquote>
            <p>— Eric S. Raymond, <cite><a href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html">Basics of the Unix Philosophy</a></cite></p>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p><em>s²</em> is tiny in size (~3kb), and implements comparatively little compared to JS frameworks.</p>
              <p>The intended use case is for highly interactive UI that needs to re-render often.</p>
              <p>It <a href="https://krausest.github.io/js-framework-benchmark/current.html">performs well</a> in benchmarks.</p>
            </aside>
          </div>

          <div>
            <h2 id="import-the-module">Import the module</h2>
            <p>A runtime environment that supports ES Modules is required without build tooling. The recommended way is to either vendor the library, or import from a CDN using the commit hash in the URL. For convenience, the following example uses the latest version.</p>
            <pre>import s2, {
  // The following are symbols, import when needed.
  root, target, mount, unmount, move,
  // The following function is for referring to templates by name.
  registerTemplate,
} from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/main.min.mjs";</pre>
            <p>Optional addons are as follows:</p>
            <pre>// Parse a subset of Mustache for templating.
import parseMustache from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/mustache.min.mjs";
&nbsp;
// Computed properties implementation.
import {
  observable, createComputed,
} from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/computed-properties.min.mjs";</pre>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Although only the main import is necessary, most practical use cases will involve Mustache templating for better ergonomics, and computed properties for state management.</p>
            </aside>
          </div>

          <div>
            <h2 id="reactive-templating">Reactive templating</h2>
            <p>The way that the reactivity model works is that mutations on the <code>Proxy</code> object returned by <em>s²</em> reflect in the DOM. This works at arbitrary levels of nesting, as well. After initializing the template, there is no need to call functions explicitly, setting keys on the <code>Proxy</code> calls the handler functions implicitly.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 72)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const state = {
  fullName: "Deli Meats",
  input() {
    ([
      this.firstName, this.lastName,
    ] = this.fullName.split(" "));
  },
  ignore(event) {
    event.preventDefault();
  },
};
state.input();
return state;</textarea><textarea spellcheck="false"><form onsubmit="{{ignore}}">
  <input
    value="{{fullName}}"
    placeholder="Full name"
    oninput="{{input}}">
</form>
<div>
  First name: <b>{{firstName}}</b>
  <br>Last name: <b>{{lastName}}</b>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>In the above example, it demonstrates propagating changes in one direction, from an input to an output. The <a href="#computed-properties">computed properties</a> addon will demonstrate how to go in the opposite direction, deriving output from input, without manual dependency tracking.</p>
          </div>
          <div>
          </div>
        </section>

        <section>
          <div>
            <h2 id="html-templates">HTML templates</h2>
            <p>By default, <code>data-</code> attributes are used for templating. This section exists for reference.</p>
            <ul>
              <li><code>data-key</code>, <code>data-template</code>: for binding keys valued by objects to templates.</li>
              <li><code>data-text</code>, <code>data-unsafe-html</code>: for setting text and HTML.</li>
              <li><code>data-class</code>: shorthand for setting class attribute.</li>
              <li><code>data-value</code>: for setting input values, also handles binding to <code>input</code> event automatically.</li>
              <li><code>data-event-*</code>: for adding event listeners.</li>
              <li><code>data-attribute-*</code>: for setting arbitrary attributes.</li>
              <li><code>data-*</code>: for setting data attributes (reflection).</li>
            </ul>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>The Mustache addon will translate templates to use <code>data-</code> attributes internally.</p>
            </aside>
          </div>

          <div>
            <h2 id="mustache-templates">Mustache templates</h2>
            <p>The Mustache addon translates a subset of Mustache into the <code>data-</code> attributes expected by <em>s²</em>. Unlike the official spec, these templates are context-aware, meaning that it behaves quite differently from string templating.</p>
            <p>Here is a quick example, notice that the <code>onclick</code> attribute actually adds an event listener:</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 54)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  counter: {
    count: 0,
    increment(event) {
      event.preventDefault();
      this.count++;
    },
  },
};</textarea><textarea spellcheck="false">
<div>
  Hello, world!<br>
  {{#counter}}
    <b>{{count}}</b>
    <button onclick="{{increment}}">
      Increment
    </button>
  {{/counter}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>There are some caveats due to the limitations of the HTML templating:</p>
            <ul>
              <li>Inverted sections are not supported. This won&apos;t work: <code>{{^section}}{{/section}}</code>.</li>
              <li>Partials can only exist as the only child of a section. For example, <code>{{#section}}{{>partial}}{{/section}}</code>.</li>
              <li>String interpolation is not allowed in attributes. This won&apos;t work: <code>&lt;p style="color: #{{hex}};"&gt;</code>, but this will: <code>&lt;p style="{{style}}"&gt;</code>.</li>
              <li>Dot notation is not supported. This includes: <code>{{.}}</code> and <code>{{key.nestedKey}}</code>.</li>
            </ul>
          </div>
          <div>
          </div>

          <div>
            <h2 id="registering-templates">Registering templates</h2>
            <p>For organizing and re-using templates, each template can be broken up into smaller templates, which can be referred to by name.</p>
            <p>Here is the same example from above, extended by using a registered template:</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>The advantage of re-using templates like this is to use the same template in different places under the hood, resulting in less memory usage. It also avoids copypasting.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 80)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">registerTemplate(
  "counter", parseMustache(`
    <b>{{count}}</b>
    <button onclick="{{increment}}">
      Increment
    </button>
`));
return {
  counter1: { count: 0, increment },
  counter2: { count: 0, increment },
};
function increment(event) {
  event.preventDefault();
  this.count++;
}</textarea><textarea spellcheck="false">
<div>
  Hello, world!<br>

  {{#counter1}}
    {{>counter}}
  {{/counter1}}

  {{#counter2}}
    {{>counter}}
  {{/counter2}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>This provides an abstraction for template re-use. However, what it does not provide is &ldquo;components&rdquo; in any sense. <em>s²</em> stays agnostic about <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web Components</a>, or even implementing its own concept of components in general. It is entirely feasible to build Web Components using <em>s²</em> without any conceptual mismatch.</p>
          </div>
          <div>
          </div>
        </section>

        <section>
          <div>
            <h2 id="mount-unmount-symbols"><code>mount</code>, <code>unmount</code> symbols</h2>
            <p>The symbols <code>mount</code> and <code>unmount</code> allow user-defined behavior to run as elements are appended and removed from the DOM. This allows for animations and arbitrary code such as integrating with third-party libraries on these events. The unmount function is particularly useful for implementing exiting animations, as it will wait for a promise to resolve before removing the node.</p>
            <p>Both <code>mount</code> and <code>unmount</code> functions have <code>node</code> as an argument, <em>but it is not the same node</em>. On mount, the node is a <code>DocumentFragment</code> before the fragment is inserted into the DOM. On unmount, the node is any top-level <code>Node</code> before the node is removed from the DOM.</p>
            <p>On unmount, the unmount function is called recursively on each child that is removed, to ensure that unmount will always be called.</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Mount and unmount are defined and run exactly once, even if the object which contained the symbols initially is replaced with another object.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 138)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const msg = "s2_is_great!";
return {
  add(event) {
    event.preventDefault();
    if (this.chars.length ===
      msg.length) return;
    this.chars.push({
      char: msg[this.chars.length],
      [mount]: mountChar,
      [unmount]: unmountChar,
    });
  },
  remove(event) {
    event.preventDefault();
    this.chars.pop();
  },
  chars: [],
};
function mountChar(node) {
  node.firstElementChild
    .classList.add("in");
}
async function unmountChar(node) {
  if (node.nodeType !== 1) return;
  node.classList.add("out");
  await new Promise(resolve =>
    setTimeout(resolve, 500));
}</textarea><textarea spellcheck="false">
<div>
  Controls:
  <button onclick="{{add}}">
    Add
  </button>
  <button onclick="{{remove}}">
    Remove
  </button>
  <br>
  Characters:
  <div class="chars">
    {{#chars}}
      <b>{{char}}</b>
    {{/chars}}
  </div>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="move-symbol"><code>move</code> symbol</h2>
            <p>The <code>move</code> symbol allows user-defined behavior to run as objects in arrays have their index changed. This allows for animations to run on this event. It is especially useful when combined with a technique called <a href="https://aerotwist.com/blog/flip-your-animations/">First, Last, Invert, Play</a> (FLIP).</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 174)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  nums: new Array(9).fill()
    .map((_, i) => {
      return {
        num: i + 1,
        [move]: animate,
      };
    }),
  shuffle(event) {
    event.preventDefault();
    this.nums.sort((a, b) =>
      Math.random() < 0.5 ? -1 : 1);
  },
};
function animate(node) {
  if (this.isMoving ||
    node.nodeType !== 1) return;
  this.isMoving = true;
  const b1 =
    node.getBoundingClientRect();
  requestAnimationFrame(() => {
    delete this.isMoving;
    const b2 =
      node.getBoundingClientRect();
    const i = b1.left - b2.left;
    const t1 = `translateX(${i}px)`;
    const t2 = 'translateX(0)';
    node.animate([
      { transform: t1 },
      { transform: t2 },
    ], {
      duration: 300,
      easing: 'ease-in-out',
    });
  });
}</textarea><textarea spellcheck="false">
<div>
  Controls:
  <button onclick="{{shuffle}}">
    Shuffle
  </button>
  <br>
  #:
  <div class="nums">
    {{#nums}}
      <b>{{num}}</b>
    {{/nums}}
  </div>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="root-target-symbol"><code>root</code>, <code>target</code> symbol</h2>
            <p>The <code>root</code> symbol exists on each function context, such as event listeners, and mount, unmount, and move functions.</p>
            <p>Its purpose is to get a reference to the top-level Proxy. This is particularly useful when there are multiple roots but functions are shared between them.</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>You should generally use this instead of referring to the Proxy returned by <em>s²</em>.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 86)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  count: 1,
  increment(event) {
    event.preventDefault();
    this.count++;
  },
  views: new Array(3).fill()
    .map((_, i) => ({
      ordinal: i + 1,
      value: "Empty", read,
    })),
};
function read(event) {
  event.preventDefault();
  this.value = this[root].count;
}</textarea><textarea spellcheck="false"><div>
  Count - <b>{{count}}</b>
  <button onclick="{{increment}}">
    Increment
  </button>
  {{#views}}
    <div>
      View {{ordinal}} -
      <b>{{value}}</b>
      <button onclick="{{read}}">
        Read
      </button>
    </div>
  {{/views}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The <code>target</code> symbol is of limited utility, it provides a way to access the target object from the Proxy. There is no built-in way in JavaScript to do this.</p>
          </div>
          <div>
          </div>

          <div>
            <h2 id="computed-properties">Computed properties</h2>
            <p>The computed properties addon derives outputs from inputs, without the need for manually tracking dependencies. It implements reactivity by proxying the objects used as inputs via <code>observable</code>. To start, the computed function must be created by passing in the mount and unmount symbols:</p>
            <pre>const computed = createComputed(mount, unmount);</pre>
            <p>In the computed properties addon, an <code>observable</code> is an object whose keys are automatically tracked by computed properties when they are read. A <code>computed</code> object&apos;s <em>methods</em> are run automatically when its dependencies change.</p>
            <p>Here is a classic spreadsheet example where there are computed cell values:</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>For any application with non-trivial complexity, computed properties are essential to writing maintainable code. However, it is not strictly necessary.</p>
              <p>Caveat: observable objects are only tracked at the top level, deeply nested observable objects aren&apos;t tracked.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 108)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const src = {
  data: [
    { price: 19.99, tax: 1.08 },
    { price: 75.00, tax: 1.06 },
    { price: 2.50, tax: 1.10 },
  ].map(observable),
};
return {
  rows: src.data.map(d => computed({
    total: () => `$${
      (d.price * d.tax).toFixed(2)}`,
    price: () => d.price,
    tax: () => d.tax,
    setPrice() {
      d.price = this.price;
    },
    setTax() {
      d.tax = this.tax;
    },
  })),
};</textarea><textarea spellcheck="false">
<div class="spreadsheet">
  <div>Price</div>
  <div>Tax rate</div>
  <div>Total</div>
  {{#rows}}
    <input
      type="number"
      step="0.01"
      value="{{price}}"
      oninput="{{setPrice}}">
    <input
      type="number"
      step="0.01"
      value="{{tax}}"
      oninput="{{setTax}}">
    <div>
      {{total}}
    </div>
  {{/rows}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>Note that in the above example, multiple observable objects are used due to the limitation that observable objects can only keep track of keys that are one-level deep.</p>
          </div>
          <div>
          </div>

          <div>
            <h2 id="computed-composition">Computed composition</h2>
            <p>Observable objects and computed objects only work on the top-level keys, which makes composition necessary.</p>
            <p>Here is the todo example from above, but refactored to use computed properties. Additionally, a confirmation dialog needs to be shown before deleting a todo. The record to be deleted is tracked via a key in the observable object, so that only one confirmation can be shown at a time.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 182)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const src = observable({
  todos: [
    'Sleep', 'Wake up',
    'Get out of bed', 'Brush teeth',
    'Get dressed',
  ],
});
return computed({
  todos() {
    return src.todos
      .map((todo, i) => computed({
        todo, remove, confirmDelete,
        isConfirming() {
          return i ===
            src.indexToDelete ?
              true : null;
        },
      }));
  },
  add,
});
function remove() {
  src.todos = src.todos
    .filter((_, i) =>
      i !== src.indexToDelete);
  delete src.indexToDelete;
}
function confirmDelete() {
  src.indexToDelete = src.todos
    .findIndex(_ => _ === this.todo);
}
function add(event) {
  event.preventDefault();
  if (!this.todo) return;
  src.todos =
    [...src.todos, this.todo];
  delete this.todo;
}</textarea><textarea spellcheck="false"><form onsubmit="{{add}}">
  <input
    value="{{todo}}"
    placeholder="Todo...">
  <button>Add</button>
</form>
<ul>
  {{#todos}}
    <li
      class="todo"
      data-confirm="{{isConfirming}}">
      <div onclick="{{confirmDelete}}">
        &#x2715;
      </div>
      <div onclick="{{remove}}">
        Delete?
      </div>
      <span>{{todo}}</span>
    </li>
  {{/todos}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>Composing observable and computed objects allows the user to decouple the data from the view.</p>
            <h3>Nesting observables in computed</h3>
            <p>How the objects are arranged is up to you, here is an example where the observable objects are nested inside of the computed objects:</p><hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>If your computed property requires using <code>this</code>, then arrow functions will not work.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 134)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = [
  { usd: 19.99 }, { usd: 75.00 },
  { usd: 2.50 }, { usd: 100.00 },
];
const cny = new Intl.NumberFormat(
  "zh-CN", { style: "currency",
             currency: "CNY" });
const jpy = new Intl.NumberFormat(
  "jp-JP", { style: "currency",
             currency: "JPY" });
return {
  rows: data.map(d => computed({
    data: observable(d),
    displayCNY() {
      return cny
        .format(this.data.usd * 6.5);
    },
    displayJPY() {
      return jpy
        .format(this.data.usd * 109);
    },
    usd: d.usd,
    setUSD() {
      this.data.usd = this.usd;
    },
  })),
};</textarea><textarea spellcheck="false">
<div class="spreadsheet">
  <div>USD</div>
  <div>CNY</div>
  <div>JPY</div>
  {{#rows}}
    <input
      type="number"
      step="0.01"
      value="{{usd}}"
      oninput="{{setUSD}}">
    <div>
      {{displayCNY}}
    </div>
    <div>
      {{displayJPY}}
    </div>
  {{/rows}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
        </section>

        <section>
          <div>
            <h2 id="performance-pitfalls">Performance pitfalls</h2>
            <p>When using computed properties, be careful about where observable properties are read from. Try to compose computed properties to be as granular as possible.</p>
            <p>Here is an example of an unoptimized list, the problem is that it does not try to reduce the amount of work done in a single computed property.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 86)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  rows: new Array(300).fill(),
  selectedIndex: 0,
});
return computed({
  rows() {
    return data.rows.map((_, i) => ({
      label: `Item ${i}`,
      isSelected:
        data.selectedIndex === i,
      select() {
        data.selectedIndex = i;
      },
    }));
  }
});</textarea><textarea spellcheck="false"><ul class="example-list">
  {{#rows}}
    <li onclick="{{select}}">
      {{label}}
      <span
        data-selected="{{isSelected}}"
      >
        selected
      </span>
    </li>
  {{/rows}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The problem is that there is just one computed property that returns a new instance of each nested object, and the slowdown is noticeable due to the event listener update occuring between each iteration. Here is the same example from above, but optimized to reduce the amount of work done in a single computed property.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 102)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  rows: new Array(300).fill(),
  selectedIndex: 0,
});
return computed({
  rows() {
    return data.rows.map((_, i) => {
      return computed({
        label: `Item ${i}`,
        isSelected() {
          return data.selectedIndex
            === i;
        },
        select() {
          data.selectedIndex = i;
        },
      });
    });
  }
});</textarea><textarea spellcheck="false"><ul class="example-list">
  {{#rows}}
    <li onclick="{{select}}">
      {{label}}
      <span
        data-selected="{{isSelected}}"
      >
        selected
      </span>
    </li>
  {{/rows}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The only changes made were to add a <code>computed</code> object on each list item, and to turn <code>isSelected</code> into a computed property. This fixes the problem by only recomputing one property by <code>n</code> times.</p>
            <p>There is still a potential slowdown even with this approach: if the length of the list changes, then each list item needs to be recomputed. This is best worked around by manually mutating the list using array methods.</p>
            <p>Computed properties are faster than just replacing a large data structure, because it allows for small, granular updates, versus updating an entire data structure.</p>
            <hr>
          </div>
          <div>
          </div>

          <div>
            <h2 id="object-re-use">Object re-use</h2>
            <p>Re-using an object multiple times in the same template requires use of computed properties.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 112)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  firstName: "Deli",
  lastName: "Meats",
});
function cData() {
  const obj = {};
  for (const key in data) {
    obj[key] = () => data[key];
  }
  return computed(obj);
}
return {
  display1: cData(),
  display2: cData(),
  reverse(event) {
    event.preventDefault();
    data.firstName = data.firstName
      .split("").reverse().join("");
    data.lastName = data.lastName
      .split("").reverse().join("");
  },
};</textarea><textarea spellcheck="false"><div>
  {{#display1}}
    <div>
      Given name first:
      {{firstName}},
      {{lastName}}
    </div>
  {{/display1}}
  {{#display2}}
    <div>
      Surname first:
      {{lastName}},
      {{firstName}}
    </div>
  {{/display2}}
    Action:
    <button onclick="{{reverse}}">
      Reverse
    </button>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The main reason for restricting objects to only appear once in a template is due to objects being mapped to a single DOM node internally.</p>
            <hr>
          </div>
          <div>
          </div>

          <div>
            <h2 id="computed-of-computed">Computed of computed</h2>
            <p>Computed objects are <strong>not</strong> observable, but they can set properties on observables. By doing so, it is possible to create computed properties of computed properties.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 108)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  number: 1,
});
return computed({
  internal: observable(),
  number() {
    return data.number;
  },
  double() {
    const x = data.number * 2;
    this.internal.double = x;
    return x;
  },
  quadruple() {
    return this.internal.double * 2;
  },
  increment(event) {
    event.preventDefault();
    data.number++;
  },
});</textarea><textarea spellcheck="false"><div>
    Number: {{number}}<br>
    Double: {{double}}<br>
    Quadruple: {{quadruple}}<br>
    Action:
    <button onclick="{{increment}}">
      Increment
    </button>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="server-side-rendering">Server-side rendering</h2>
            <p>A DOM implementation is required for server-side rendering. <strong>The recommended implementation is <a href="https://github.com/WebReflection/linkedom">linkedom</a>.</strong> Since s² is designed with DOM in mind, it is safer to emulate the DOM than to pretend it does not exist.</p>
            <p>By setting the <code>window</code> property on the default import, the entire context can be changed in runtime. This allows client-side apps to be rendered with one line of code.</p>
            <pre>import { parseHTML } from "https://cdn.jsdelivr.net/gh/WebReflection/linkedom@latest/worker.js";
&nbsp;
const { window } = parseHTML(...);
s2.window = window;</pre>
            <p>If you are using the Mustache addon, it requires something similar.</p>
            <pre>// For Mustache, either set window or import processMustache.
import parseMustache, { processMustache } from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/mustache.min.mjs";
&nbsp;
// Option 1 (recommended approach)
parseMustache.window = window;
&nbsp;
// Option 2
const template = window.document.createElement("template");
template.innerHTML = processMustache(...);</pre>
            <p>To get the output of the rendered HTML page:</p>
            <pre>window.document.toString()</pre>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Server-side rendering with s² is simply rendering the client-side application.</p>
              <p>One way to think about it, is to export the client-side app so that the server-side can import it and change its window.</p>
              <p>This also means that you will have to implement APIs to set the current URL and wait for data to load before rendering.</p>
            </aside>
          </div>
        </section>

        <section>
          <div>
            <footer>
              <h4>␄</h4>
            </footer>
            <hr>
          </div>
          <div></div>
        </section>
      </main>
    </div>
  </body>
</html>
