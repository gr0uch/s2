<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>s²</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDQuMjMzIDQuMjMzIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOjMuNzc5NTM7ZmlsbDojM2ZiNjhiO2ZpbGwtb3BhY2l0eToxIiBkPSJNMCAwdjE1Ljk5OGgxNS45OThWMEgwem04IDhoN3Y0LjY5aC0yLjUwNmwuNjMzLTEuMjMxYy4xMzMtLjI1NS4yLS41MzEuMi0uODI4IDAtLjUxOC0uMTgyLS45NTgtLjU0NC0xLjMyYTEuNzggMS43OCAwIDAgMC0xLjMxMi0uNTQzYy0uNTEzIDAtLjk1LjE4My0xLjMxMy41NWExLjgwMSAxLjgwMSAwIDAgMC0uNTQzIDEuMzE3YzAgLjMzLjA3Ny42MzMuMjMuOTA2LjE1NC4yNzMuMzc0LjQ5OS42Ni42NzZsLjY4NC0xLjIxOWEuNC40IDAgMCAxLS4xNC0uMjk3YzAtLjA5Ni4wMzUtLjE4LjEwNS0uMjVhLjM0OC4zNDggMCAwIDEgLjI1NC0uMTFjLjI0OCAwIC4zNzEuMTA2LjM3MS4zMTdhLjUyOC41MjggMCAwIDEtLjA3LjI1NGwtLjA1OS4xMS0xLjcxIDMuMjFIMTVWMTVIOFY4eiIgdHJhbnNmb3JtPSJzY2FsZSguMjY0NTgpIi8+PHBhdGggZD0iTTEuMzg1LjkwNXEtLjM5NC4yOTQtLjM5NC42MzIgMCAuNDM0LjMxMy40MzQuMTExIDAgLjM1NC0uMTkyLjI0Mi0uMTkxLjQ3NS0uMTkxLjIyMiAwIC4zNTkuMTE2LjEzNy4xMTEuMTM3LjI5OCAwIC4xNzctLjE3Ny4zNzQtLjE3Ny4xOTEtLjYyNy40NC0uNDUuMjQyLS41NzEuMzIzLS4xMjEuMDg2LS4yMDcuMjA3bC0uMDI2LS4wMy4wMy0uMDYuMDM2LS4wNzdMMSAzLjA4US45MiAzLjAwMi43ODQgMy4wMDJxLS4yNTMgMC0uNC4yNjNsLS4wMjUuMDMtLjAzLS4wM3EwLS4wOC4yMjgtLjMxMy4yMzMtLjIzNy41NS0uMjM3LjIzOCAwIC40MTUuMTUxbC4wNC4wMjYuMDctLjA0cS4zMzktLjE3Ny40MzQtLjMyNC4wOTYtLjE0Ny4wOTYtLjMwOCAwLS4xNzctLjEwNi0uMjc3LS4xMDEtLjEwNy0uMjY4LS4xMDctLjEyMSAwLS4zNjkuMTkyLS4yNDIuMTkxLS40NS4xOTEtLjE2IDAtLjI3Ny0uMTI2LS4xMTctLjEzLS4xMTctLjMwOCAwLS4yNTIuMjIyLS41MDV0Ljc5OC0uNTU2cS4yODMtLjE1MS4zOTQtLjMxOGwuMDE2LS4wMi4wMi4wNC0uMDkuMTItLjA4Ny4xMjJxLjE2OC4xNDEuMjczLjE0MS4xMzEgMCAuMjc4LS4xbC4wMi4wM3EwIC4wMjUtLjIzNy4yMzgtLjIzMy4yMDctLjM2NC4yMDctLjEyMSAwLS40MzQtLjI3OHoiIHN0eWxlPSJsaW5lLWhlaWdodDoxLjI1Oy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246UGFyY2htZW50O3BhaW50LW9yZGVyOm5vcm1hbDtmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjEiIGZvbnQtc2l6ZT0iMTAuNTgzIiBmb250LWZhbWlseT0iUGFyY2htZW50IiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iLjEyOSIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==" type="image/svg+xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <meta property="og:title" content="s²">
    <meta property="og:description" content="s² is a function for reactive web UI." />
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://gr0uch.github.io/s2/s2.png">
    <meta property="og:image:type" content="image/png">
    <script type="module" src="./docs.mjs"></script>
    <style>
      :root {
        --w: 78rem;
        --h: 19px;
        --h2: 17px;
        --h3: 14px;
        --h4: 12px;
        --l: calc(1rem * 9 / 5);
        --u: calc(1 / 4);

        /*--f-h: Garamond, Big Caslon Medium, Palatino Linotype, Palatino, serif;*/
        --f-b: Space Grotesk, -apple-system, BlinkMacSystemFont, Microsoft Sans Serif, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        --f-m: Space Mono, SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;

        --c-fg: rgb(215, 210, 220);
        --c-fh: rgb(255, 255, 255);
        --c-fg2: rgb(155, 150, 160);
        --c-fg3: rgb(125, 120, 130);
        --c-bg: rgb(30, 32, 38);
        --c-a: rgb(40, 42, 48);
        --c-a2: rgb(46, 48, 54);
        --c-a3: rgb(66, 68, 74);
        --c-l: #3fb68b;
        --c-l2: rgba(63, 182, 139, 0.06);
        --c-h: #e34c26;
        --c-e: #6e40c9;
      }
      ::selection { background: var(--c-e); color: var(--c-fg); }
      *::-webkit-scrollbar { background-color: var(--c-a2); width: 8px; }
      *::-webkit-scrollbar-thumb { background-color: var(--c-a3); }
      * { margin: 0; padding: 0; border: 0; box-sizing: border-box; }
      html { font-size: var(--h); }
      body { line-height: var(--l); background: var(--c-a); color: var(--c-fg); font-family: var(--f-b); }
      h1, h2, h3, h4, h5, h6 { font-size: inherit; font-weight: inherit; }
      h2 { font-size: calc(1rem * var(--u) * 5); font-weight: 700; margin: calc(1rem * 12 * var(--u)) 0 var(--l); padding: calc(1rem * var(--u) * 2) 0; color: var(--c-fh); }
      h2 code { font-size: inherit; }
      h3 { font-size: 1rem; font-weight: 700; margin: 0 0 var(--l); }
      h6 { font-size: var(--h3); text-transform: uppercase; font-weight: 300; font-style: italic; letter-spacing: 0.1rem; color: var(--c-fg2); }
      ul, ol { padding-left: 2rem; }
      p, ul, ol, pre, blockquote { margin-bottom: var(--l); }
      blockquote { color: var(--c-fg2); border-left: calc(1rem * var(--u) * 1) var(--c-fg3) solid; padding-left: calc(1rem * var(--u) * 3); }
      a { color: inherit; text-decoration: inherit; }
      code, pre { font-family: var(--f-m); font-size: var(--h2); font-variant-ligatures: none; }
      textarea, pre { color: var(--c-fg2); background: none; padding: calc(1rem * var(--u) * 2) calc(1rem * var(--u) * 3); font-family: var(--f-m); font-size: var(--h3); resize: vertical; font-variant-ligatures: none; white-space: nowrap; }
      pre { box-shadow: 0 calc(1rem * var(--u) * 3) calc(1rem * var(--u) * 9) var(--c-bg); border-radius: calc(1rem * var(--u)); white-space: pre-wrap; counter-reset: line; }
      pre > code { display: block; counter-increment: line; position: relative; padding: 0 0 0 calc(1rem * var(--u) * 6) !important; font-size: inherit; }
      pre > code::before { content: counter(line); display: inline-block; position: absolute; top: 0; right: calc(100% - 1rem * var(--u) * 4); color: var(--c-fg3); }
      textarea:focus, input:focus { outline: 1px var(--c-l) solid; }

      /* layout */
      .container { position: relative; min-height: 100%; max-width: var(--w); display: flex; margin: auto; hyphens: auto; }
      body::before { display: block; content: " "; position: fixed; top: 0; right: 0; height: 100%; width: calc((100% - var(--w)) / 2 + 1px); background: var(--c-a2); }
      #main-nav { position: sticky; top: 0; flex: 1; padding: calc(1rem * 28 * var(--u)) 0 0 calc(1rem * var(--u) * 1); margin: 0 var(--l) 0 0; align-self: flex-start; color: var(--c-fg2); height: 100vh; overflow: auto; }
      #main-nav h5 { font-size: var(--h3); font-weight: 700; }
      #main-nav code { font-size: var(--h4); }
      #main-nav h5 + h5 { margin-top: var(--l); }
      #main-nav ul { padding: 0; list-style-type: none; font-style: italic; font-size: var(--h3); font-weight: 300; }
      #main-nav li::before { content: "-"; margin-right: calc(1rem * var(--u) * 1); color: var(--c-fg3); }
      #main-nav .logo { position: absolute; top: 0; width: calc(1rem * var(--u) * 8); padding-top: calc(1rem * var(--u) * 2); background: var(--c-l); border-radius: 0 0 calc(1rem * var(--u)) calc(1rem * var(--u)); overflow: hidden; }
      #main-nav svg { display: block; height: calc(1rem * var(--u) * 8); width: calc(1rem * var(--u) * 8); background: var(--c-a); }
      #content { flex: 5; }
      #content a, #main-nav h5:first-of-type a { text-decoration: underline var(--c-l) 2px; }
      #content a { font-weight: 700; }
      #content > section { display: grid; grid-template-columns: 9fr 4fr; grid-template-rows: min-content; border-bottom: 4px var(--c-a2) solid; }
      #content > section:first-of-type { border-color: var(--c-a3); /*height: calc(100vh + 4px);*/ }
      #content > section:first-of-type > div:nth-of-type(2n) { background: linear-gradient(to right, var(--c-a), var(--c-a2)); }
      #content > section > div { padding: 0 calc(1rem * var(--u) * 22) 0 0; position: relative; }
      #content > section > div:nth-of-type(2n) { padding: 0 var(--l); }
      #content > section > div:nth-of-type(2n)::before { display: block; content: " "; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--c-a2); z-index: -1; box-sizing: border-box; }
      #content > section > div:last-of-type { padding-bottom: calc(1rem * var(--u) * 16); }
      #content > section > div:nth-last-of-type(2) > :last-child { margin-bottom: calc(1rem * var(--u) * 16) !important; }
      #content > section > div > :last-child:not(.live-example.code) { margin-bottom: 0; }
      #content > section > div > footer { padding: var(--l) 0 0; color: var(--c-fg3); text-align: center; }
      #content > section > div > footer > h4 { font-size: 2em; }
      #content > section code { background: var(--c-a2); border-radius: calc(1rem * var(--u)); padding: 0 calc(1rem * var(--u)); }
      #content > section pre code { background: inherit; border-radius: inherit; }
      .params { position: relative; z-index: 0; margin: calc(1rem * var(--u) * 26) 0 0 0; font-size: calc(1rem * var(--u) * 5); line-height: calc(1rem * var(--u) * 10); border-radius: calc(1rem * var(--u)); color: var(--c-l); }
      .params b { display: inline-block; width: calc(1rem * var(--u) * 18); font-weight: inherit; }
      .params i { display: inline-block; margin: 0 calc(1rem * var(--u) * 2); }
      .params code { font-size: inherit; background-color: var(--c-l2); }

      /* examples */
      .live-example.code { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: min-content 1fr; box-shadow: 0 calc(1rem * var(--u) * 4) calc(1rem * var(--u) * 8) var(--c-bg); border-radius: calc(1rem * var(--u)); margin-bottom: calc(1rem * var(--u) * 10); }
      .live-example.code h6 { background: var(--c-bg); padding: calc(1rem * var(--u) * 1) calc(1rem * var(--u) * 3); border-bottom: 1px var(--c-a2) solid; border-right: 1px var(--c-a2) solid; }
      .live-example.code h6:first-of-type { border-radius: calc(1rem * var(--u)) 0 0 0; }
      .live-example.code h6:last-of-type { border-radius: 0 calc(1rem * var(--u)) 0 0; border-right: none; }
      .live-example.code textarea { height: 100%; border-right: 1px var(--c-a2) solid; }
      .live-example.code textarea:last-of-type { border-right: none; }
      aside { color: var(--c-fg2); font-size: var(--h3); }
      aside code { font-size: inherit; }
      aside h6 { padding: calc(1rem * var(--u) * 1) 0; margin-bottom: calc(1rem * var(--u) * 2); border-bottom: 2px var(--c-a) solid; }
      .live-example.output b { color: var(--color); }
      .live-example.output ul { list-style-type: none; padding: 0; margin: 0; }
      .live-example.output li > div { float: right; color: var(--c-h); cursor: pointer; font-weight: 700; }
      aside:not(.output) { margin-top: calc(1rem * var(--u) * 16); }
      .live-example.output .chars { display: inline-flex; }
      .live-example.output .chars > * { pointer-events: none; }
      @keyframes char-in { 0% { transform: scale(5); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
      @keyframes char-out { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(5); opacity: 0; } }
      .live-example.output .in { animation: char-in 0.5s; }
      .live-example.output .out { animation: char-out 0.5s; }
      .live-example.output .nums { display: inline-flex; }
      .live-example.output .nums > * { margin: 0 calc(1rem * var(--u) * 1); }
      .live-example.output .spreadsheet { display: grid; grid-template-columns: 1fr 1fr 1fr; column-gap: calc(1rem * var(--u) * 3); row-gap: calc(1rem * var(--u) * 1); }
      .live-example.output .todo > :nth-child(2) { display: none; }
      .live-example.output .todo[data-confirm] > :nth-child(2) { display: block; }
      .live-example.output .todo[data-confirm] > :nth-child(1) { display: none; }
      .live-example.output .example-list { max-height: calc(var(--l) * 8); overflow: auto; }
      .live-example.output .example-list > * { cursor: pointer; }
      .live-example.output .example-list [data-selected="false"] { display: none; }

      /* primary */
      .live-example.primary.code { position: relative; left: calc(1rem * var(--u) * 0); margin-right: calc(1rem * var(--u) * 0); }
      .live-example.primary.code h6 { background: var(--c-l2); }
      .live-example.primary.code textarea { background: var(--c-a); }
      .live-example.primary.output { background: var(--c-l2); backdrop-filter: blur(var(--h4)); margin: 0 calc(1rem * var(--u) * -4); padding: 0 calc(1rem * var(--u) * 4) calc(1rem * var(--u) * 4); border-radius: calc(1rem * var(--u)); }
      .live-example.primary.output input { background: var(--c-a2); }
      .live-example.primary.output input:focus { outline: none; }
      .live-example.primary h6 { color: var(--c-l); border-bottom-width: 2px; border-bottom-color: var(--c-l); font-weight: 700; font-style: inherit; padding-top: calc(1rem * var(--u) * 2); }

      /* forms */
      form { display: flex; margin: calc(1rem * var(--u) * 4) 0; }
      form > :first-child { border-radius: calc(1rem * var(--u)) 0 0 calc(1rem * var(--u)); }
      form > :last-child { border-radius: 0 calc(1rem * var(--u)) calc(1rem * var(--u)) 0; }
      input, button { font-family: inherit; font-size: inherit; background: inherit; color: inherit; }
      form button { background: var(--c-bg); }
      form input { width: 0; }
      input { background: var(--c-a); height: calc(1rem * var(--u) * 7); padding: 0 calc(1rem * var(--u) * 2); flex: 1; width: 100%; border-radius: calc(1rem * var(--u)); }
      input[type="checkbox"] { height: auto; width: auto; margin: 0 calc(1rem * var(--u) * 1) 0 0; }
      button { cursor: pointer; padding: 0 calc(1rem * var(--u) * 3); color: var(--c-e); font-weight: 700; }

      /* rEspoNsiVe */
      @media (max-width: 1240px) {
        :root {
          --h: 17px;
          --h3: 12px;
        }
        .container { flex-direction: column; }
        .params { margin: calc(1rem * var(--u) * 8) 0; padding: calc(var(--l) * 1 / 2) 0; }
        h2 { margin-top: calc(1rem * var(--u) * 6); }
        #main-nav { position: static; padding-top: 0; height: auto; }
        #main-nav .logo { margin-bottom: 0; position: static; }
        #main-nav .logo ~ * { display: none; }
        .live-example.primary.output { margin: 0 calc(1rem * var(--u) * -2); }
        .live-example.primary.code { position: inherit; left: 0; margin-right: 0; }
        .live-example.output { padding-bottom: calc(var(--l) / 4); }
        #content { padding: 0 calc(1rem * var(--u) * 1); }
        #content > section { display: block; }
        #content > section > div { padding: 0; }
        #content > section > div > :last-child:not(.live-example.code):not(hr) { margin-bottom: var(--l); }
        #content > section > div:nth-child(2) { padding-top: 0; }
        #content > section > div:last-of-type { padding-bottom: 0; }
        #content > section > div:nth-of-type(2n) { padding: 0 calc(var(--l) * 1 / 4); }
        #content > section > div:nth-of-type(2n + 1) > :last-child { margin-bottom: calc(1rem * var(--u) * 8); }
        #content > section > div:nth-last-of-type(2) > hr:last-child { margin-bottom: 0 !important; }
        aside:not(.output) {  margin-top: 0; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav id="main-nav">
        <div class="logo">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 4.233 4.233"><path style="stroke-width:3.77953;fill:#3fb68b;fill-opacity:1" d="M0 0v15.998h15.998V0H0zm8 8h7v4.69h-2.506l.633-1.231c.133-.255.2-.531.2-.828 0-.518-.182-.958-.544-1.32a1.78 1.78 0 0 0-1.312-.543c-.513 0-.95.183-1.313.55a1.801 1.801 0 0 0-.543 1.317c0 .33.077.633.23.906.154.273.374.499.66.676l.684-1.219a.4.4 0 0 1-.14-.297c0-.096.035-.18.105-.25a.348.348 0 0 1 .254-.11c.248 0 .371.106.371.317a.528.528 0 0 1-.07.254l-.059.11-1.71 3.21H15V15H8V8z" transform="scale(.26458)"/><path d="M1.385.905q-.394.294-.394.632 0 .434.313.434.111 0 .354-.192.242-.191.475-.191.222 0 .359.116.137.111.137.298 0 .177-.177.374-.177.191-.627.44-.45.242-.571.323-.121.086-.207.207l-.026-.03.03-.06.036-.077L1 3.08Q.92 3.002.784 3.002q-.253 0-.4.263l-.025.03-.03-.03q0-.08.228-.313.233-.237.55-.237.238 0 .415.151l.04.026.07-.04q.339-.177.434-.324.096-.147.096-.308 0-.177-.106-.277-.101-.107-.268-.107-.121 0-.369.192-.242.191-.45.191-.16 0-.277-.126-.117-.13-.117-.308 0-.252.222-.505t.798-.556q.283-.151.394-.318l.016-.02.02.04-.09.12-.087.122q.168.141.273.141.131 0 .278-.1l.02.03q0 .025-.237.238-.233.207-.364.207-.121 0-.434-.278z" style="line-height:1.25;-inkscape-font-specification:Parchment;paint-order:normal;fill:none;fill-opacity:1" font-size="10.583" font-family="Parchment" stroke="#fff" stroke-width=".129" stroke-linecap="square" fill="none"/></svg>
        </div>
        <h5><a href="https://github.com/gr0uch/s2">GitHub: gr0uch/s2</a></h5>
        <h5><a href="#intro">Intro</a></h5>
        <ul>
          <li><a href="#rationale">Rationale</a></li>
          <li><a href="#install-from-npm">Install from <code>npm</code></a></li>
          <li><a href="#import-the-module">Import the module</a></li>
          <li><a href="#reactive-templating">Reactive templating</a></li>
        </ul>
        <h5><a href="#templating">Templating</a></h5>
        <ul>
          <li><a href="#html-templates">HTML templates</a></li>
          <li><a href="#mustache-templates">Mustache templates</a></li>
          <li><a href="#registering-templates">Registering templates</a></li>
        </ul>
        <h5><a href="#symbols">Symbols</a></h5>
        <ul>
          <li><a href="#mount-unmount-symbols"><code>mount</code>, <code>unmount</code> symbols</a></li>
          <li><a href="#move-symbol"><code>move</code> symbol</a></li>
          <li><a href="#root-target-symbol"><code>root</code>, <code>target</code> symbol</a></li>
        </ul>

        <h5><a href="#computeds">Computeds</a></h5>
        <ul>
          <li><a href="#computed-properties">Computed properties</a></li>
          <li><a href="#computed-composition">Computed composition</a></li>
          <li><a href="#computed-of-computed">Computed of computed</a></li>
        </ul>
        <h5><a href="#addendum">Addendum</a></h5>
        <ul>
          <li><a href="#server-side-rendering">Server-side rendering</a></li>
          <li><a href="#styling">Styling</a></li>
          <li><a href="#performance-pitfalls">Performance pitfalls</a></li>
          <li><a href="#object-re-use">Object re-use</a></li>
          <li><a href="#time-travel">Time travel</a></li>
        </ul>
      </nav>
      <main id="content">
        <section>
          <div id="top">
            <p class="params">
              <code>s2(object, template);</code><br><br>
              Returns <code>[proxy, documentFragment]</code>, a reactive view model and a fragment containing its elements.
            </p>
            <hr>
          </div>
          <div></div>
        </section>

        <section id="intro">
          <div>
            <h2 id="rationale">Rationale</h2>
            <p><em>s²</em> is a single function that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxies</a> mutable data to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect">reflect</a> in the DOM. Its paradigm models user interface entirely in terms of state, and avoids mixing logic with the presentation layer (inlining JavaScript, such as JSX). <em>s²</em> has a few design goals:</p>
            <ul>
              <li>Enable separation of application logic from the presentation layer. For example, unlike React which combines hooks, templates (JSX), and arbitrary code in a render function, <em>s²</em> has data, functions that operate on the data, and declarative templates.</li>
              <li>The only required API is its main function, which handles rendering and event listening. Advanced features such as <a href="#computeds">computed properties</a> are implemented as addons.</li>
              <li>Templates are logic-less. This differs from prior art such as JSX where embedded JavaScript is allowed. Due to this constraint, logic-less templating maps well to <em>s²</em>, and there is an addon for <a href="#mustache-templates">Mustache templates</a> that is aware of HTML context.</li>
            </ul>
            <p>Here is a sample to-do app built with <em>s²</em>:</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p><em>s²</em> is tiny in size (~3kb), and implements comparatively little compared to JS frameworks.</p>
              <p>The intended use case is for highly interactive UI that needs to re-render often.</p>
              <p>It <a href="https://krausest.github.io/js-framework-benchmark/current.html">performs well</a> in benchmarks.</p>
            </aside>
          </div>
          <div>
            <div class="live-example primary code" style="min-height: calc(1rem * var(--u) * 126)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  add, todos: [
    'Sleep', 'Wake up',
    'Brush teeth', 'Get dressed',
  ].map(todo => ({
    todo, toggle, remove,
  })),
};
function add(event) {
  event.preventDefault();
  this[root].todos.unshift({
    todo: this.todo,
    remove, toggle, });
  delete this.todo;
}
function toggle() {
  this.t = !this.t ?
    "line-through" : null;
}
function remove() {
  const i = this[root].todos
    .findIndex(_ => _ === this);
  this[root].todos.splice(i, 1);
}</textarea><textarea spellcheck="false"><form onsubmit="{{add}}">
  <input required
    value="{{todo}}"
    placeholder="Todo...">
  <button>Add</button>
</form>
<ul>
  {{#todos}}
    <li>
      <div onclick="{{remove}}">
        &#x2715;</div>
      <label>
        <input
          type="checkbox"
          oninput="{{toggle}}">
        <span
          style:text-decoration="{{t}}"
        >
          {{todo}}
        </span>
      </label>
    </li>
  {{/todos}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example primary output" style="min-height: calc(1rem * var(--u) * 72)">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>Its design is influenced by this quote:</p>
            <blockquote>Even the simplest procedural logic is hard for humans to verify, but quite complex data structures are fairly easy to model and reason about... Data is more tractable than program logic. It follows that where you see a choice between complexity in data structures and complexity in code, choose the former. More: in evolving a design, you should actively seek ways to shift complexity from code to data.</blockquote>
            <p>— Eric S. Raymond, <cite><a href="http://www.catb.org/~esr/writings/taoup/html/ch01s06.html">Basics of the Unix Philosophy</a></cite></p>
          </div>
          <div></div>

          <div>
            <h2 id="install-from-npm">Install from <code>npm</code> (Node.js build system)</h2>
            <pre>npm install s2-engine</pre>
            <p><strong>Important:</strong> this is an ES module, most modern build systems will support this out of the box. The exports are as follows:</p>
            <pre>import s2, {
  // Symbols
  root, target, mount, unmount, move,

  // Templating (prefer `html` tagged template literal)
  html, parseMustache, registerTemplate,

  // Computed properties
  observable, computed, ref,
} from "s2-engine";</pre>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p><em>s²</em> can be considered a template engine, or template processor.</p>
            </aside>
          </div>

          <div>
            <h2 id="import-the-module">Import the module (browser, Deno)</h2>
            <p>A runtime environment that supports ES Modules is required without build tooling. The recommended way is to either vendor the library, or import from a CDN using the commit hash in the URL. For convenience, the following example uses the latest version.</p>
            <pre>import s2, {
  // The following are symbols, import when needed.
  root, target, mount, unmount, move,

  // The following function is for referring to templates by name.
  registerTemplate,
} from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/main.min.mjs";</pre>
            <p>Using the default export:</p>
            <pre>const obj = { ... };
const template = /* see Mustache addon or use querySelector */;
const [proxy, fragment] = s2(obj, template);</pre>
            <p>Optional addons are as follows:</p>
            <pre>// Parse a subset of Mustache for templating.
import parseMustache, { createMustacheTag } from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/mustache.min.mjs";
&nbsp;
// Computed properties implementation.
import {
  observable, createComputed, ref,
} from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/computed-properties.min.mjs";</pre>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Although only the main import is necessary, most practical use cases will involve Mustache templating for better ergonomics, and computed properties for state management.</p>
            </aside>
          </div>

          <div>
            <h2 id="reactive-templating">Reactive templating</h2>
            <p>The way that the reactivity model works is that mutations on the <code>Proxy</code> object returned by <em>s²</em> reflect in the DOM. This works at arbitrary levels of nesting, as well. After initializing the template, there is no need to call functions explicitly, setting keys on the <code>Proxy</code> calls the handler functions implicitly.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 72)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const state = {
  fullName: "Deli Meats",
  input() {
    ([
      this.firstName, this.lastName,
    ] = this.fullName.split(" "));
  },
  ignore(event) {
    event.preventDefault();
  },
};
state.input();
return state;</textarea><textarea spellcheck="false"><form onsubmit="{{ignore}}">
  <input
    value="{{fullName}}"
    placeholder="Full name"
    oninput="{{input}}">
</form>
<div>
  First name: <b>{{firstName}}</b>
  <br>Last name: <b>{{lastName}}</b>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>In the above example, it demonstrates propagating changes in one direction, from an input to an output. The <a href="#computed-properties">computed properties</a> addon will demonstrate how to go in the opposite direction, deriving output from input, without manual dependency tracking.</p>
          </div>
          <div>
          </div>
        </section>

        <section id="templating">
          <div>
            <h2 id="html-templates">HTML templates</h2>
            <p>By default, <code>data-</code> attributes are used for templating. This section exists for reference.</p>
            <ul>
              <li><code>data-key</code>, <code>data-template</code>: for binding keys valued by objects to templates.</li>
              <li><code>data-text</code>, <code>data-unsafe-html</code>: for setting text and HTML.</li>
              <li><code>data-class</code>: shorthand for setting class attribute.</li>
              <li><code>data-classlist-*</code>: shorthand for toggling classes.</li>
              <li><code>data-value</code>: for setting input values, also handles binding to <code>input</code> event automatically.</li>
              <li><code>data-event-*</code>: for adding event listeners.</li>
              <li><code>data-attribute-*</code>: for setting arbitrary attributes.</li>
              <li><code>data-style-*</code>: for setting CSS properties.</li>
              <li><code>data-*</code>: for setting data attributes (reflection).</li>
            </ul>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>The Mustache addon will translate templates to use <code>data-</code> attributes internally.</p>
            </aside>
          </div>

          <div>
            <h2 id="mustache-templates">Mustache templates</h2>
            <p>The Mustache addon translates a subset of Mustache into the <code>data-</code> attributes expected by <em>s²</em>. Unlike the official spec, these templates are context-aware, meaning that it behaves quite differently from string templating.</p>
            <p>Here is a quick example, notice that the <code>onclick</code> attribute actually adds an event listener:</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 62)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  counter: {
    count: 0,
    color: "var(--c-l)",
    increment(event) {
      event.preventDefault();
      this.count++;
    },
  },
};</textarea><textarea spellcheck="false">
<div>
  Hello, world!<br>
  {{#counter}}
    <b style:--color="{{color}}">
      {{count}}
    </b>
    <button onclick="{{increment}}">
      Increment
    </button>
  {{/counter}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <h3>Mustache features</h3>
            <ul>
              <li><code>{{text}}</code> and <code>{{{rawText}}}</code> inside of an element&apos;s body map to <code>textContent</code> and <code>innerHTML</code> respectively.</li>
              <li>Attributes such as <code>&lt;p style="{{style}}"&gt;</code> will map to the element&apos;s attributes.</li>
              <li>Mustache sections <code>{{#section}}...{{/section}}</code> can contain inlined content, or exactly one partial: <code>{{>partial}}</code>.</li>
            </ul>

            <h3>Mustache extensions (not in spec)</h3>
            <ul>
              <li>The custom <code>class:</code> <em>attribute directive</em> sets individual classes, <a href="https://svelte.dev/tutorial/classes">similar to Svelte</a>.</li>
              <li>The custom <code>style:</code> <em>attribute directive</em> sets individual CSS properties efficiently, <a href="https://svelte.dev/docs#template-syntax-element-directives-style-property">similar to Svelte</a>.</li>
              <li>Event listeners such as <code>&lt;form onsubmit="{{action}}"&gt;</code> will add an event listener on the element.</li>
              <li>Fixing JSX-style self-closing tags (<code>&lt;div &sol;&gt;</code>) is opt-in functionality: <code>parseMustache.selfClosing = true;</code> because it changes the behavior, browsers do not parse this as self-closing.</li>
            </ul>

            <h3>Caveats</h3>
            <ul>
              <li>Inverted sections are not supported. This won&apos;t work: <code>{{^section}}{{/section}}</code>.</li>
              <li>Partials can only exist as the only child of a section. For example, <code>{{#section}}{{>partial}}{{/section}}</code>.</li>
              <li>String interpolation is not allowed in attributes. This won&apos;t work: <code>&lt;p style="color: #{{hex}};"&gt;</code>, but this will: <code>&lt;p style="{{style}}"&gt;</code>.</li>
              <li>Dot notation is not supported. This includes: <code>{{.}}</code> and <code>{{key.nestedKey}}</code>.</li>
            </ul>
          </div>
          <div>
            <aside class="output">
              <h6>Aside</h6>
              <p>The Mustache addon is a small, regular-expression based function that parses a subset of Mustache that maps to the built-in HTML-based templating.</p>
              <p>If you are using VSCode, these plugins might be of interest:</p>
              <ul>
                <li><a href="https://marketplace.visualstudio.com/items?itemName=Tobermory.es6-string-html">es6-string-html</a></li>
                <li><a href="https://marketplace.visualstudio.com/items?itemName=bierner.lit-html">lit-html</a></li>
              </ul>
            </aside>
          </div>

          <div>
            <h2 id="registering-templates">Registering templates</h2>
            <p>For organizing and re-using templates, each template can be broken up into smaller templates, which can be referred to by name.</p>
            <p>Here is the same example from above, extended by using a registered template:</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>The advantage of re-using templates like this is to use the same template in different places under the hood, resulting in less memory usage. It also avoids copypasting.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 80)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">registerTemplate(
  "counter", parseMustache(`
    <b>{{count}}</b>
    <button onclick="{{increment}}">
      Increment
    </button>
`));
return {
  counter1: { count: 0, increment },
  counter2: { count: 0, increment },
};
function increment(event) {
  event.preventDefault();
  this.count++;
}</textarea><textarea spellcheck="false">
<div>
  Hello, world!<br>

  {{#counter1}}
    {{>counter}}
  {{/counter1}}

  {{#counter2}}
    {{>counter}}
  {{/counter2}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>This provides an abstraction for template re-use. However, what it does not provide is &ldquo;components&rdquo; in any sense. <em>s²</em> stays agnostic about <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web Components</a>, or even implementing its own concept of components in general. It is entirely feasible to build Web Components using <em>s²</em> without any conceptual mismatch.</p>
            <p>For improved ergonomics, there is the <code>createMustacheTag</code> function, which will allow one to re-use templates without naming them, and also interpolate templates in tagged template literals.</p>
            <pre>const html = createMustacheTag(registerTemplate);
const name = html`{{firstName}} {{lastName}}`;
const greeting = html`
  Hello
  {{#person}}${name}{{/person}}
  !`;</pre>
            <p>In the above example, <em>name</em> will be a separate template which is referred to by <em>greeting</em>, they are connected by an internal hash.</p>
            <p><strong>Warning:</strong> templates can only be interpolated inside of a section (refer to the <a href="#mustache-templates">limitations</a>). If you meant to re-use part of a template, interpolate a string instead of another template.</p>
          </div>
          <div>
          </div>
        </section>

        <section id="symbols">
          <div>
            <h2 id="mount-unmount-symbols"><code>mount</code>, <code>unmount</code> symbols</h2>
            <p>The symbols <code>mount</code> and <code>unmount</code> allow user-defined behavior to run as elements are appended and removed from the DOM. This allows for animations and arbitrary code such as integrating with third-party libraries on these events. The unmount function is particularly useful for implementing exiting animations, as it will wait for a promise to resolve before removing the node.</p>
            <p>Both <code>mount</code> and <code>unmount</code> functions have <code>node</code> as an argument, <em>but it is not the same node</em>. On mount, the node is a <code>DocumentFragment</code> before the fragment is inserted into the DOM. On unmount, the node is any top-level <code>Node</code> before the node is removed from the DOM.</p>
            <p>On unmount, the unmount function is called recursively on each child that is removed, to ensure that unmount will always be called.</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Mount and unmount are defined and run exactly once, even if the object which contained the symbols initially is replaced with another object.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 138)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const msg = "s2_is_great!";
return {
  add(event) {
    event.preventDefault();
    if (this.chars.length ===
      msg.length) return;
    this.chars.push({
      char: msg[this.chars.length],
      [mount]: mountChar,
      [unmount]: unmountChar,
    });
  },
  remove(event) {
    event.preventDefault();
    this.chars.pop();
  },
  chars: [],
};
function mountChar(node) {
  node.firstElementChild
    .classList.add("in");
}
async function unmountChar(node) {
  if (node.nodeType !== 1) return;
  node.classList.add("out");
  await new Promise(resolve =>
    setTimeout(resolve, 500));
}</textarea><textarea spellcheck="false">
<div>
  Controls:
  <button onclick="{{add}}">
    Add
  </button>
  <button onclick="{{remove}}">
    Remove
  </button>
  <br>
  Characters:
  <div class="chars">
    {{#chars}}
      <b>{{char}}</b>
    {{/chars}}
  </div>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="move-symbol"><code>move</code> symbol</h2>
            <p>The <code>move</code> symbol allows user-defined behavior to run as objects in arrays have their index changed. This allows for animations to run on this event. It is especially useful when combined with a technique called <a href="https://aerotwist.com/blog/flip-your-animations/">First, Last, Invert, Play</a> (FLIP).</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 174)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  nums: new Array(9).fill()
    .map((_, i) => {
      return {
        num: i + 1,
        [move]: animate,
      };
    }),
  shuffle(event) {
    event.preventDefault();
    this.nums.sort((a, b) =>
      Math.random() - 0.5);
  },
};
function animate(node) {
  if (this.isMoving ||
    node.nodeType !== 1) return;
  this.isMoving = true;
  const b1 =
    node.getBoundingClientRect();
  requestAnimationFrame(() => {
    delete this.isMoving;
    const b2 =
      node.getBoundingClientRect();
    const i = b1.left - b2.left;
    const t1 = `translateX(${i}px)`;
    const t2 = 'translateX(0)';
    node.animate([
      { transform: t1 },
      { transform: t2 },
    ], {
      duration: 300,
      easing: 'ease-in-out',
    });
  });
}</textarea><textarea spellcheck="false">
<div>
  Controls:
  <button onclick="{{shuffle}}">
    Shuffle
  </button>
  <br>
  #:
  <div class="nums">
    {{#nums}}
      <b>{{num}}</b>
    {{/nums}}
  </div>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="root-target-symbol"><code>root</code>, <code>target</code> symbol</h2>
            <p>The <code>root</code> symbol exists on each function context, such as event listeners, and mount, unmount, and move functions.</p>
            <p>Its purpose is to get a reference to the top-level Proxy. This is particularly useful when there are multiple roots but functions are shared between them.</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>You should generally use this instead of referring to the Proxy returned by <em>s²</em>.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 86)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">return {
  count: 1,
  increment(event) {
    event.preventDefault();
    this.count++;
  },
  views: new Array(3).fill()
    .map((_, i) => ({
      ordinal: i + 1,
      value: "Empty", read,
    })),
};
function read(event) {
  event.preventDefault();
  this.value = this[root].count;
}</textarea><textarea spellcheck="false"><div>
  Count - <b>{{count}}</b>
  <button onclick="{{increment}}">
    Increment
  </button>
  {{#views}}
    <div>
      View {{ordinal}} -
      <b>{{value}}</b>
      <button onclick="{{read}}">
        Read
      </button>
    </div>
  {{/views}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The <code>target</code> symbol is of limited utility, it provides a way to access the target object from the Proxy. There is no built-in way in JavaScript to do this.</p>
          </div>
          <div>
          </div>
        </section>

        <section id="computeds">
          <div>
            <h2 id="computed-properties">Computed properties</h2>
            <p>The computed properties addon derives outputs from inputs, without the need for manually tracking dependencies. It implements reactivity by proxying the objects used as inputs via <code>observable</code>. To start, the computed function must be created by passing in the mount and unmount symbols:</p>
            <pre>const computed = createComputed(mount, unmount);</pre>
            <p>In the computed properties addon, an <code>observable</code> is an object whose keys are automatically tracked by computed properties when they are read. A <code>computed</code> object&apos;s <em>methods</em> are run automatically when its dependencies change.</p>
            <p>Here is a classic spreadsheet example where there are computed cell values:</p>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>For any application with non-trivial complexity, computed properties are essential to writing maintainable code. However, it is not strictly necessary.</p>
              <p>Observable objects are only tracked at the top level by default, it can be deeply nested by passing in the second argument as <code>true</code>.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 120)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const s = observable({
  data: [
    { price: 19.99, tax: 1.08 },
    { price: 75.00, tax: 1.06 },
    { price: 2.50, tax: 1.10 },
  ],
}, true);
return computed({
  rows() {
    return s.data.map(d => computed({
      total: () => `$${
        (d.price * d.tax)
          .toFixed(2)}`,
      price: () => d.price,
      tax: () => d.tax,
      setPrice() {
        d.price = this.price;
      },
      setTax() {
        d.tax = this.tax;
      },
    }));
  },
});</textarea><textarea spellcheck="false">
<div class="spreadsheet">
  <div>Price</div>
  <div>Tax rate</div>
  <div>Total</div>
  {{#rows}}
    <input
      type="number"
      step="0.01"
      value="{{price}}"
      oninput="{{setPrice}}">
    <input
      type="number"
      step="0.01"
      value="{{tax}}"
      oninput="{{setTax}}">
    <div>
      {{total}}
    </div>
  {{/rows}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>Note that in the above example, the observable object has a second argument passed in as <code>true</code>. This tells the observable to be <em>deeply observable</em>, including nested objects. When using deep observables, it is possible to delete observables and replace them with new observables. This works because dependencies are tracked on every run of the computed function.</p>
            <h3>Deep observability</h3>
            <p>Opt-in to deep observability by passing the second argument as <code>true</code>:</p>
            <pre>const source = observable({ ... }, true);</pre>
            <p>When an observable is deeply observable, any arbitrary path may be used in computed properties. This means that paths can be deleted, replaced with different objects, mutated, and the dependent computed properties would still react to changes.</p>
            <h3>Using <code>ref()</code> to opt-out of deep observability</h3>
            <p>In case one knows in advance that an object will not have its properties changed, the <code>ref()</code> function will assign an internal symbol on the object to mark it as a reference only.</p>
            <pre>const source = observable({
  notDeep: ref({ ... }), // this object will not be deeply observable
}, true);</pre>
            <hr>
          </div>
          <div>
          </div>

          <div>
            <h2 id="computed-composition">Computed composition</h2>
            <p>Computed properties only work on the top-level keys, which makes composition necessary.</p>
            <p>Here is the todo example from above, but refactored to use computed properties. Additionally, a confirmation dialog needs to be shown before deleting a todo. The record to be deleted is tracked via a key in the observable object, so that only one confirmation can be shown at a time.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 174)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">
const todos = [
  'Sleep', 'Wake up', 'Get out of bed',
  'Brush teeth', 'Get dressed',
];
const src = observable({
  todos,
}, true);
return computed({
  todos() {
    return src.todos
      .map((todo, i) => computed({
        todo, remove, confirmDelete,
        isConfirming() {
          return i ===
            src.indexToDelete ?
              true : null;
        },
      }));
  },
  add,
});
function remove() {
  src.todos
    .splice(src.indexToDelete, 1);
  delete src.indexToDelete;
}
function confirmDelete() {
  src.indexToDelete = src.todos
    .findIndex(_ => _ === this.todo);
}
function add(event) {
  event.preventDefault();
  if (!this.todo) return;
  src.todos.unshift(this.todo);
  delete this.todo;
}</textarea><textarea spellcheck="false"><form onsubmit="{{add}}">
  <input
    value="{{todo}}"
    placeholder="Todo...">
  <button>Add</button>
</form>
<ul>
  {{#todos}}
    <li
      class="todo"
      data-confirm="{{isConfirming}}">
      <div onclick="{{confirmDelete}}">
        &#x2715;
      </div>
      <div onclick="{{remove}}">
        Delete?
      </div>
      <span>{{todo}}</span>
    </li>
  {{/todos}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>Composing observable and computed objects allows the user to decouple the data from the view.</p>
            <h3>Nesting observables in computed</h3>
            <p>How the objects are arranged is up to you, here is an example where the observable objects are nested inside of the computed objects:</p><hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>If your computed property requires using <code>this</code>, then arrow functions will not work.</p>
            </aside>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 134)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = [
  { usd: 19.99 }, { usd: 75.00 },
  { usd: 2.50 }, { usd: 100.00 },
];
const cny = new Intl.NumberFormat(
  "zh-CN", { style: "currency",
             currency: "CNY" });
const jpy = new Intl.NumberFormat(
  "jp-JP", { style: "currency",
             currency: "JPY" });
return {
  rows: data.map(d => computed({
    data: observable(d),
    displayCNY() {
      return cny
        .format(this.data.usd * 6.5);
    },
    displayJPY() {
      return jpy
        .format(this.data.usd * 109);
    },
    usd: d.usd,
    setUSD() {
      this.data.usd = this.usd;
    },
  })),
};</textarea><textarea spellcheck="false">
<div class="spreadsheet">
  <div>USD</div>
  <div>CNY</div>
  <div>JPY</div>
  {{#rows}}
    <input
      type="number"
      step="0.01"
      value="{{usd}}"
      oninput="{{setUSD}}">
    <div>
      {{displayCNY}}
    </div>
    <div>
      {{displayJPY}}
    </div>
  {{/rows}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="computed-of-computed">Computed of computed</h2>
            <p>Computed objects are <strong>not</strong> observable, but they can set properties on observables. By doing so, it is possible to create computed properties of computed properties.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 112)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  number: 1,
});

const derived = observable(computed({
  double() {
    return data.number * 2;
  },
  quadruple() {
    return this.double * 2;
  },
}));

return computed({
  number: () => data.number,
  double: () => derived.double,
  quadruple: () => derived.quadruple,
  increment(event) {
    event.preventDefault();
    data.number++;
  },
});</textarea><textarea spellcheck="false"><div>
  Number: {{number}}<br>
  Double: {{double}}<br>
  Quadruple: {{quadruple}}<br>
  Action:
  <button onclick="{{increment}}">
    Increment
  </button>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>When a computed object is passed into observable, its <code>mount</code> function is called automatically. If needed, its <code>unmount</code> function needs to be called manually.</p>
            <hr>
          </div>
          <div>
          </div>
        </section>

        <section id="addendum">
          <div>
            <h2 id="server-side-rendering">Server-side rendering</h2>
            <p>A DOM implementation is required for server-side rendering. <strong>The recommended implementation is <a href="https://github.com/WebReflection/linkedom">linkedom</a>.</strong> Since s² is designed with DOM in mind, it is safer to emulate the DOM than to pretend it does not exist.</p>
            <p>By setting the <code>window</code> property on the default import, the entire context can be changed in runtime. This allows client-side apps to be rendered with one line of code.</p>
            <pre>import { parseHTML } from "https://cdn.jsdelivr.net/gh/WebReflection/linkedom@latest/worker.js";
&nbsp;
const { window } = parseHTML(...);
s2.window = window;</pre>
            <p>If you are using the Mustache addon, it requires something similar.</p>
            <pre>// For Mustache, either set window or import processMustache.
import parseMustache, { processMustache } from "https://cdn.jsdelivr.net/gh/gr0uch/s2@latest/dist/mustache.min.mjs";
&nbsp;
// Option 1 (recommended approach)
parseMustache.window = window;
&nbsp;
// Option 2
const template = window.document.createElement("template");
template.innerHTML = processMustache(...);</pre>
            <p>To get the output of the rendered HTML page:</p>
            <pre>window.document.toString()</pre>
            <hr>
          </div>
          <div>
            <aside>
              <h6>Aside</h6>
              <p>Server-side rendering with s² is simply rendering the client-side application.</p>
              <p>One way to think about it, is to export the client-side app so that the server-side can import it and change its window.</p>
              <p>This also means that you will have to implement APIs to set the current URL and wait for data to load before rendering.</p>
            </aside>
          </div>

          <div>
            <h2 id="styling">Styling</h2>
            <p>s² is agnostic about styling, and works well with framework-agnostic tooling. If you are already familiar with <a href="https://styled-components.com/">Styled Components</a>, then <a href="https://goober.js.org/">Goober</a> is a familiar alternative that implements the same API.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 108)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const { css } = await import(
  "https://esm.run/goober"
);

const containerStyle = () => css`
> :nth-child(1) {
  color: var(--c-l);
}
> :nth-child(2) {
  color: var(--c-e);
}
> :nth-child(3) {
  color: var(--c-h);
}
`;

return computed({
  containerClass() {
    return containerStyle();
  },
});</textarea><textarea spellcheck="false"><div class="{{containerClass}}">
  <div>
    First
  </div>
  <div>
    Second
  </div>
  <div>
    Third
  </div>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>

          <div>
            <h2 id="performance-pitfalls">Performance pitfalls</h2>
            <p>When using computed properties, be careful about where observable properties are read from. Try to compose computed properties to be as granular as possible.</p>
            <p>Here is an example of an unoptimized list, the problem is that it does not try to reduce the amount of work done in a single computed property.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 86)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  rows: new Array(100).fill(),
  selectedIndex: 0,
});
return computed({
  rows() {
    return data.rows.map((_, i) => ({
      label: `Item ${i}`,
      isSelected:
        data.selectedIndex === i,
      select() {
        data.selectedIndex = i;
      },
    }));
  }
});</textarea><textarea spellcheck="false"><ul class="example-list">
  {{#rows}}
    <li onclick="{{select}}">
      {{label}}
      <span
        data-selected="{{isSelected}}"
      >
        selected
      </span>
    </li>
  {{/rows}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The problem is that there is just one computed property that returns a new instance of each nested object, and there is a slight slowdown due to diffing the entire data. Here is the same example from above, but optimized to reduce the amount of work done in a single computed property.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 102)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  rows: new Array(100).fill(),
  selectedIndex: 0,
});
return computed({
  rows() {
    return data.rows.map((_, i) => {
      return computed({
        label: `Item ${i}`,
        isSelected() {
          return data.selectedIndex
            === i;
        },
        select() {
          data.selectedIndex = i;
        },
      });
    });
  }
});</textarea><textarea spellcheck="false"><ul class="example-list">
  {{#rows}}
    <li onclick="{{select}}">
      {{label}}
      <span
        data-selected="{{isSelected}}"
      >
        selected
      </span>
    </li>
  {{/rows}}
</ul></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The only changes made were to add a <code>computed</code> object on each list item, and to turn <code>isSelected</code> into a computed property. This fixes the problem by only recomputing one property by <code>n</code> times.</p>
            <p>There is still a potential slowdown even with this approach: if the length of the list changes, then each list item needs to be recomputed. This is best worked around by manually mutating the list using array methods, because there is no way that the computed function knows that only a few values changed up front.</p>
            <p>Computed properties are faster than just replacing a large data structure, because it allows for small, granular updates, versus updating an entire data structure.</p>
            <hr>
          </div>
          <div>
          </div>

          <div>
            <h2 id="object-re-use">Object re-use</h2>
            <p>Re-using an object multiple times in the same template requires use of computed properties.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 112)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">const data = observable({
  firstName: "Deli",
  lastName: "Meats",
});
function cData() {
  const obj = {};
  for (const key in data) {
    obj[key] = () => data[key];
  }
  return computed(obj);
}
return {
  display1: cData(),
  display2: cData(),
  reverse(event) {
    event.preventDefault();
    data.firstName = data.firstName
      .split("").reverse().join("");
    data.lastName = data.lastName
      .split("").reverse().join("");
  },
};</textarea><textarea spellcheck="false"><div>
  {{#display1}}
    <div>
      Given name first:
      {{firstName}},
      {{lastName}}
    </div>
  {{/display1}}
  {{#display2}}
    <div>
      Surname first:
      {{lastName}},
      {{firstName}}
    </div>
  {{/display2}}
    Action:
    <button onclick="{{reverse}}">
      Reverse
    </button>
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
          <div>
            <p>The main reason for restricting objects to only appear once in a template is due to objects being mapped to a single DOM node internally.</p>
            <hr>
          </div>
          <div>
          </div>

          <div>
            <h2 id="time-travel">Time travel</h2>
            <p>Implement your own time travel, this is just an example. It takes a little creativity, but it's not too difficult.</p>
            <hr>
          </div>
          <div>
          </div>
          <div>
            <div class="live-example code" style="min-height: calc(1rem * var(--u) * 112)">
              <h6>JavaScript</h6>
              <h6>HTML + Mustache</h6>
              <textarea spellcheck="false">
const reversal = Symbol("reversal");
const reversals = [];
let group = [];
const timeHandler = {
  get() {
    const value = Reflect
      .get(...arguments);
    if (value &&
      typeof value === "object") {
      const p = new Proxy(
        value, timeHandler);
      return p;
    }
    return value;
  },
  set(t, k, v, r) {
    if (typeof v === "object" &&
      Object.hasOwn(v, reversal)) {
      t[k] = v[reversal];
      return true;
    } else {
      group.push([r, k, t[k]]);
      queueMicrotask(() => {
        if (!group.length) return;
        reversals.push(group);
        group = [];
      });
    }
    return Reflect.set(...arguments);
  },
};
const data = new Proxy(observable({
  actions: [],
}, true), timeHandler);
return computed({
  updatedAt: () => data.updatedAt,
  actions() {
    void data.updatedAt;
    return data.actions
      .map(d => ({ d }));
  },
  goLeft(event) {
    event.preventDefault();
    data.actions.push("left");
    data.updatedAt = Date.now();
  },
  goRight(event) {
    event.preventDefault();
    data.actions.push("right");
    data.updatedAt = Date.now();
  },
  undo(event) {
    event.preventDefault();
    if (!reversals.length) return;
    const groups = reversals.pop();
    for (const [
      obj, key, value
] of groups) {
      obj[key] = {
        [reversal]: value,
      };
    }
  },
});</textarea><textarea spellcheck="false"><div>
  Go:
  <button onclick="{{goLeft}}">
    Left
  </button>
  <button onclick="{{goRight}}">
    Right
  </button>
  <button onclick="{{undo}}">
    Undo
  </button>
  <br>
  Updated at: {{updatedAt}}
  {{#actions}}
    <div>
      Move: {{d}}
    </div>
  {{/actions}}
</div></textarea>
            </div>
          </div>
          <div>
            <aside class="live-example output">
              <h6>Output</h6>
              <div>
                <noscript>JavaScript must be enabled!</noscript>
              </div>
            </aside>
          </div>
        </section>

        <section>
          <div>
            <footer>
              <h4>␄</h4>
            </footer>
            <hr>
          </div>
          <div></div>
        </section>
      </main>
    </div>
  </body>
</html>
